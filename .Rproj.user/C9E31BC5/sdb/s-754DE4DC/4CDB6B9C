{
    "contents" : "source('etricutils.R')\nsource('etricommon.R')\nsource('etricbase.R')\nsource('etricassignment.R')\nsource('etricpaiwisecmp.R')\nsource('etriccardinalities.R')\nsource('etricreturns.R')\n\netric.init <- function(performances, profiles, assignments, monotonicity, th, cardinalities, pCk, pCl){\n  stopifnot(ncol(performances) == ncol(profiles))\n  stopifnot(is.null(assignments) || ncol(assignments) == 3)\n  stopifnot((is.null(pCk)) || (ncol(pCk) == 3))\n  stopifnot(is.null(pCl) || ncol(pCl) == 3)\n  stopifnot(nrow(assignments) < nrow(performances))\n  stopifnot(nrow(th) == ncol(performances))\n  stopifnot(nrow(th) == length(monotonicity))\n  \n  message(\"--- Constructing model\")\n  \n  n <- nrow(performances)\n  p <- nrow(profiles)-2 # p - liczba klas. Klas jest o 2 mniej niÅ¼ profili\n  m <- ncol(performances)\n  \n  A <- 1:n ## an\n  B <- 0:(p+1) ## profile\n  H <- 1:p ## klasy \n  J <- 1:m ## j\n  \n  etric <- list()\n  etric$n <- n\n  etric$p <- p\n  etric$m <- m\n  \n  var <- etricutils.createVarnames(n, p, J, pCk, pCl)\n  \n  etric$binaryvar <- var$binary\n  \n  etric$constr$lhs <- intiLHS(c(var$float, var$binary))\n  etric$constr$dir <- initDIR()\n  etric$constr$rhs <- initRHS()\n  \n  etric <- etric.buildBaseModel(etric, performances, profiles, th, monotonicity)\n  etric <- etric.buildAEModel(etric, assignments)\n  etric <- etric.buildPCModel(etric, pCk, pCl )\n  etric <- etric.buildCCModel(etric, cardinalities)\n  return(etric)\n}\n\n\netric.possibleAssigment <- function(etric, solver){\n  possibleRanking <- matrix(FALSE,ncol=etric$p, nrow=etric$n, \n                            dimnames= list(paste0(\"a\",1:etric$n), paste0(\"C\", 1:etric$p)))\n  for(a in 1:etric$n){\n    for(h in 1:etric$p){\n      etric <- createPAModel(etric, a, h)\n      objFunction <- etriutils.buildObjectiveFunction(varnames=colnames(etric$constr$lhs),objectivesVarNames=etricutils.e())\n      varTypes <- etriutils.getConstraintTypes(allvarnames=colnames(etric$constr$lhs),binaryVarNames=etric$binary) \n      ret <- etriutils.solve(solver=solver, objectioveFunction=objFunction,varTypes=varTypes,\n                             lhs=etric$constr$lhs,dir=etric$constr$dir, rhs=etric$constr$rhs, max=TRUE)\n      possibleRanking[a,h] <-  ret$status$code == 0 && ret$objval > 0\n    }\n  }\n  return(possibleRanking)\n}\n\n\netric.necessaryAssigment <- function(etric, solver){\n  necessaryRanking <- matrix(FALSE,ncol=etric$p, nrow=etric$n, \n                            dimnames= list(paste0(\"a\",1:etric$n), paste0(\"C\", 1:etric$p)))\n  for(a in 1:etric$n){\n    for(h in 1:etric$p){\n      \n      ret1 <- list(objval=1, list(status=list(code=0)))\n      ret2 <- list(objval=1, list(status=list(code=0)))\n      \n      objFunction <- etriutils.buildObjectiveFunction(varnames=colnames(etric$constr$lhs),objectivesVarNames=etricutils.e())\n      varTypes <- etriutils.getConstraintTypes(allvarnames=colnames(etric$constr$lhs),binaryVarNames=etric$binary) \n      if(h < etric$p){\n        na1 <- createNA1Model(etric, a, h)\n        ret1 <- etriutils.solve(solver=solver, objectioveFunction=objFunction,varTypes=varTypes,\n                            lhs=na1$constr$lhs,dir=na1$constr$dir, rhs=na1$constr$rhs, max=TRUE)\n      }\n      if(h >1){\n        na2 <- createNA2Model(etric, a, h)\n        ret2 <- etriutils.solve(solver=solver, objectioveFunction=objFunction,varTypes=varTypes,\n                                lhs=na2$constr$lhs,dir=na2$constr$dir, rhs=na2$constr$rhs, max=TRUE)\n      }\n      necessaryRanking[a,h] <-  ret1$status$code != 0 && ret1$objval <= 0 && ret2$status$code != 0 && ret2$objval <= 0\n    }\n  }\n  return(necessaryRanking)\n}\n\n\netric.isFeasible <- function(etric, solver){\n  objFunction <- etriutils.buildObjectiveFunction(varnames=colnames(etric$constr$lhs),objectivesVarNames=etricutils.e())\n  varTypes <- etriutils.getConstraintTypes(allvarnames=colnames(etric$constr$lhs),binaryVarNames=etric$binary) \n  ret <- etriutils.solve(solver, objectioveFunction=objFunction,varTypes=varTypes,\n                         lhs=etric$constr$lhs,dir=etric$constr$dir, rhs=etric$constr$rhs,max=TRUE)\n  return(ret$status$code == 0 && ret$objval > 0)\n}\n\netric.necessaryPreferenceRelation <- function(etric, solver){\n  necessaryRelation <- matrix(TRUE,ncol=etric$n, nrow=etric$n, \n                             dimnames= list(paste0(\"a\",1:etric$n), paste0(\"a\", 1:etric$n)))\n  for(a in 1:etric$n){\n    for(b in 1:etric$n){\n      for(h in 1:(etric$p-1)){\n        objFunction <- etriutils.buildObjectiveFunction(varnames=colnames(etric$constr$lhs),objectivesVarNames=etricutils.e())\n        varTypes <- etriutils.getConstraintTypes(allvarnames=colnames(etric$constr$lhs),binaryVarNames=etric$binary) \n        \n        pl <- createPLModel(etric, a, b, h)\n        ret1 <- etriutils.solve(solver, objectioveFunction=objFunction,varTypes=varTypes,\n                               lhs=pl$constr$lhs,dir=pl$constr$dir, rhs=pl$constr$rhs,max=TRUE)\n        pr <- createPRModel(etric, a, b, h)\n        ret2 <- etriutils.solve(solver, objectioveFunction=objFunction,varTypes=varTypes,\n                               lhs=pr$constr$lhs,dir=pr$constr$dir, rhs=pr$constr$rhs,max=TRUE)\n        necessaryRelation[a,b] <- necessaryRelation[a,b] && ret1$status$code != 0 && ret1$objval <= 0 && ret2$status$code != 0 && ret2$objval <= 0\n        if(necessaryRelation[a,b] == FALSE){\n          break;\n        }\n      }\n    }\n  }\n  return(necessaryRelation)\n}\n\netric.classCardinalities <- function(etric, max, solver){\n  colname <- \"MAX\"\n  if(!max) {\n    colname <- \"MIN\"\n  }\n  classCardinalities <- matrix(0,ncol = 1, nrow = etric$p, dimnames=list(paste0(\"C\", 1:etric$p), colname))\n  for(h in 1:etric$p){\n    varnames <- etricutils.vAH(1:etric$n, h)\n    objFunction <- etriutils.buildObjectiveFunction(varnames=colnames(etric$constr$lhs),objectivesVarNames=varnames)\n    varTypes <- etriutils.getConstraintTypes(allvarnames=colnames(etric$constr$lhs),binaryVarNames=etric$binary)  \n    ret <- etriutils.solve(solver, objectioveFunction=objFunction,varTypes=varTypes,\n                            lhs=etric$constr$lhs,dir=etric$constr$dir, rhs=etric$constr$rhs,max=max)\n    classCardinalities[h,] <- ret$objval\n  }                             \n                               \n  return(classCardinalities)\n}\n\netric.createBorderProfiles <- function(alternatives, profiles, monotocity){\n  minp <- rep(0,ncol(alternatives))\n  maxp <- rep(0,ncol(alternatives))\n  for(c in 1:ncol(alternatives)){\n    if(monotocity[c]){\n      minp[c] <- min(alternatives[,c])\n      maxp[c] <- max(alternatives[,c])\n    }else{\n      minp[c] <- max(alternatives[,c])\n      maxp[c] <- min(alternatives[,c])\n    }\n  }\n  return(rbind(minp,profiles,maxp))\n}\n\n",
    "created" : 1409318895719.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1448991592",
    "id" : "4CDB6B9C",
    "lastKnownWriteTime" : 1409455671,
    "path" : "C:/Users/Patryk/Desktop/Praca Magisterska/ELECTRE TRI C/etric/etric.R",
    "project_path" : "etric.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}